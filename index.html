<!doctype html>
<html lang="zh-Hant">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"/>
<title>å¤§ç‰† ARï½œå–®éŒ¨é–å®šï¼‹æ ¡æ­£ï¼ˆä¸ä¾è³´ #mindar-* é¸å–å™¨ï¼‰</title>

<!-- A-Frame -> MindARï¼ˆé †åºå¾ˆé‡è¦ï¼‰ -->
<script src="https://unpkg.com/aframe@1.4.2/dist/aframe.min.js"></script>
<script src="https://unpkg.com/mind-ar@1.2.2/dist/mindar-image-aframe.prod.js"></script>

<style>
  html,body{margin:0;height:100%;background:#000;color:#0f0;font-family:monospace;overflow:hidden}

  /* æ»¿ç‰ˆèˆ‡å±¤ç´š */
  a-scene{position:fixed !important;inset:0 !important;width:100vw !important;height:100vh !important;z-index:1 !important}
  /* MindAR ç›¸æ©Ÿç•«é¢ï¼ˆç¨å¾Œç”¨ JS å¥—åˆ°æ­£ç¢ºçš„ <video>/<canvas> ä¸Šï¼‰ */
  .cam-fit{
    position:fixed !important; inset:0 !important;
    width:100vw !important; height:100vh !important;
    object-fit:cover !important; transform:none !important;
    z-index:0 !important; opacity:1 !important; display:block !important;
  }
  canvas.a-canvas{
    width:100vw !important; height:100vh !important;
    background:transparent !important; z-index:1 !important;
    pointer-events:none !important;
  }

  /* éš±è— MindAR å…§å»ºé®ç½©/åœˆåœˆï¼ˆé¿å…æ“‹é¡é ­ï¼‰ */
  .mindar-ui-loading, .mindar-ui-scanning{ display:none !important; }

  #top{position:fixed;left:8px;top:8px;z-index:10}
  #log{position:fixed;left:8px;bottom:8px;right:8px;height:140px;overflow:auto;
       background:rgba(0,0,0,.55);padding:8px;z-index:10;font-size:12px;line-height:1.25}
  #ctrl{position:fixed;left:8px;bottom:160px;z-index:10;background:rgba(0,0,0,.5);
        border-radius:10px;padding:8px;display:none}
  #ctrl button{margin:2px 3px;padding:8px 12px}
  .row{margin:4px 0}
</style>
</head>
<body>
<div id="top">
  <button id="btnStart">å•Ÿå‹• AR</button>
  <span id="status">æœªå•Ÿå‹•</span>
</div>

<div id="ctrl">
  <div class="row">
    ä½ç½®ï¼š<button onclick="nudge(-step,0)">â†</button>
    <button onclick="nudge(step,0)">â†’</button>
    <button onclick="nudge(0,step)">â†‘</button>
    <button onclick="nudge(0,-step)">â†“</button>
  </div>
  <div class="row">
    æ—‹è½‰Zï¼š<button onclick="rot(-rotStep)">â†º</button>
    <button onclick="rot(rotStep)">â†»</button>
  </div>
  <div class="row">
    å°ºå¯¸ï¼š<button onclick="scaleMul(0.98)">ç¸®å°</button>
    <button onclick="scaleMul(1.02)">æ”¾å¤§</button>
  </div>
  <div class="row">
    ç²¾åº¦ï¼š
    <button onclick="setFine()">ç´°</button>
    <button onclick="setCoarse()">ç²—</button>
    <button onclick="resetAdj()">é‡ç½®å¾®èª¿</button>
    <button onclick="saveCfg()">ğŸ’¾ å„²å­˜</button>
    <button onclick="reload()">é‡æ–°è¼‰å…¥</button>
  </div>
</div>

<div id="log"></div>

<a-scene
  embedded
  color-space="sRGB"
  vr-mode-ui="enabled:false"
  device-orientation-permission-ui="enabled:false"
  mindar-image="imageTargetSrc: ./wall-anchor.mind; autoStart: false; maxTrack: 1;"
  renderer="alpha: true; colorManagement: true; physicallyCorrectLights: true">

  <a-assets>
    <video id="vid" src="./video.mp4" loop playsinline webkit-playsinline muted preload="auto" crossorigin="anonymous"></video>
  </a-assets>

  <!-- éŒ¨é» -->
  <a-entity id="marker" mindar-image-target="targetIndex: 0"></a-entity>

  <!-- é–å®šå¾Œçš„ç‰†é¢å½±ç‰‡ -->
  <a-entity id="wallPlane" visible="false">
    <a-video id="wallVideo" src="#vid" width="15.14" height="3.283"
             material="shader: flat; side: double;" position="0 0 0"></a-video>
  </a-entity>

  <!-- å¾Œé¡é ­ -->
  <a-entity camera="facingMode: environment"></a-entity>
</a-scene>

<script>
const logEl = document.getElementById('log');
const log = s=>{console.log(s); logEl.textContent += s+"\n"; logEl.scrollTop=logEl.scrollHeight;}
const statusEl = document.getElementById('status');
const btnStart = document.getElementById('btnStart');
const ctrl = document.getElementById('ctrl');
const scene = document.querySelector('a-scene');
const marker = document.getElementById('marker');
const wall   = document.getElementById('wallPlane');
const video  = document.getElementById('vid');
let locked = false;

/* ç‰†é¢å¹¾ä½•ï¼ˆå…¬å°ºï¼‰ */
const WALL_W = 15.14, WALL_H = 3.283;
const ANCHOR_X = 1.73,  ANCHOR_Y = 0.46;

/* å¾®èª¿è¨­å®š */
const LS_KEY = 'WALL_AR_LOCK_V2';
let adj = JSON.parse(localStorage.getItem(LS_KEY) || '{"ox":0,"oy":0,"rz":0,"s":1}');
let step = 0.02, rotStep = 0.8;
let basePose = null;

/* ====== Pose helpers ====== */
function applyResetPose(){
  if(!basePose) return;
  wall.object3D.position.copy(basePose.pos);
  wall.object3D.quaternion.copy(basePose.quat);
  wall.object3D.scale.copy(basePose.scl);
  const q = wall.object3D.quaternion;
  const right = new THREE.Vector3(1,0,0).applyQuaternion(q);
  const up    = new THREE.Vector3(0,1,0).applyQuaternion(q);
  wall.object3D.position.addScaledVector(right, adj.ox);
  wall.object3D.position.addScaledVector(up,    adj.oy);
  wall.object3D.rotateZ(THREE.MathUtils.degToRad(adj.rz));
  wall.object3D.scale.multiplyScalar(adj.s);
}
function nudge(dx,dy){ adj.ox += dx; adj.oy += dy; applyResetPose(); }
function rot(d){ adj.rz += d; applyResetPose(); }
function scaleMul(m){ adj.s *= m; applyResetPose(); }
function setFine(){ step=0.02; rotStep=0.8; log('ç²¾åº¦=ç´°'); }
function setCoarse(){ step=0.10; rotStep=3; log('ç²¾åº¦=ç²—'); }
function saveCfg(){ localStorage.setItem(LS_KEY, JSON.stringify(adj)); log('å·²å„²å­˜è¨­å®šï¼š'+JSON.stringify(adj)); }
function resetAdj(){ adj={ox:0,oy:0,rz:0,s:1}; applyResetPose(); log('å·²é‡ç½®å¾®èª¿'); }
function reload(){ location.reload(); }

/* ====== Boot helpers ====== */
async function waitSceneLoaded(el){
  if (el.hasLoaded) return;
  await new Promise(res => el.addEventListener('loaded', res, {once:true}));
}
async function ensureCameraPermission(){
  if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
    throw new Error('æ­¤ç€è¦½å™¨ä¸æ”¯æ´ getUserMedia æˆ–æœªå…è¨±ç›¸æ©Ÿ');
  }
  const stream = await navigator.mediaDevices.getUserMedia({
    video: { facingMode: { ideal: "environment" } }, audio: false
  });
  stream.getTracks().forEach(t => t.stop());
}

/* ====== æ‰¾å‡º MindAR æ’å…¥çš„ <video>/<canvas>ï¼ˆä¸é å›ºå®š idï¼‰ ====== */
async function waitForCameraNodesFlexible(timeoutMs = 10000){
  const t0 = performance.now();
  return await new Promise((resolve, reject)=>{
    const tick = ()=>{
      // å€™é¸ videoï¼šå…·æœ‰ srcObjectï¼ˆMediaStreamï¼‰çš„ï¼Œä¸”ä¸æ˜¯æˆ‘å€‘çš„ #vid
      const videos = Array.from(document.querySelectorAll('video'));
      const camVideos = videos.filter(v => v !== video && 'srcObject' in v && v.srcObject);
      // å€™é¸ canvasï¼šä¸æ˜¯ A-Frame çš„ .a-canvasï¼Œä¸”é¢ç© > 0ï¼Œä¸”é è¿‘ç›¸æ©Ÿ video
      const canvases = Array.from(document.querySelectorAll('canvas'));
      const nonAFrameCanvases = canvases.filter(c => !c.classList.contains('a-canvas') && c.width*c.height >= 1);

      // å˜—è©¦å°±è¿‘é…å°ï¼šæ‰¾èˆ‡ç›¸æ©Ÿ video åŒçˆ¶å±¤æˆ–ç›¸é„°çš„ canvas
      let pickV = camVideos[0] || null;
      let pickC = null;
      if (pickV){
        const siblings = new Set(pickV.parentElement ? Array.from(pickV.parentElement.querySelectorAll('canvas')) : []);
        pickC = Array.from(siblings).find(c => !c.classList.contains('a-canvas')) || nonAFrameCanvases[0] || null;
      }

      if (pickV && pickC){
        return resolve({v: pickV, c: pickC, allVideos: videos.length, camVideos: camVideos.length, allCanvases: canvases.length});
      }
      if (performance.now() - t0 > timeoutMs) {
        return reject(new Error(`camera nodes not found (videos=${videos.length}, camVideos=${camVideos.length}, canvases=${canvases.length})`));
      }
      requestAnimationFrame(tick);
    };
    tick();
  });
}

/* ====== Start AR ====== */
btnStart.onclick = async ()=>{
  try{
    statusEl.textContent = 'è«‹æˆæ¬Šç›¸æ©Ÿâ€¦';
    await ensureCameraPermission();
    statusEl.textContent = 'å•Ÿå‹•ä¸­â€¦';
    await waitSceneLoaded(scene);

    const arSystem =
      scene.systems['mindar-image-system'] ||
      scene.systems['mindar-image'] ||
      (scene.components['mindar-image']?.system);

    if (!arSystem || !arSystem.start) {
      statusEl.textContent = 'å•Ÿå‹•å¤±æ•—ï¼ˆMindAR æœªåˆå§‹åŒ–ï¼‰';
      log('ğŸŸ¥ MindAR system not ready');
      return;
    }

    await arSystem.start();
    statusEl.textContent = 'è«‹å°æº–éŒ¨é»';
    log('âœ… AR å·²å•Ÿå‹•ï¼Œç­‰å¾… targetFoundâ€¦');

    /* === é—œéµï¼šä¸ä¾è³´å›ºå®š idï¼Œå½ˆæ€§å°‹æ‰¾ç›¸æ©Ÿç¯€é» === */
    try{
      const {v, c, allVideos, camVideos, allCanvases} = await waitForCameraNodesFlexible();
      log(`ğŸ“· æ‰¾åˆ°ç›¸æ©Ÿç¯€é»ï¼ˆvideos:${allVideos} camVideos:${camVideos} canvases:${allCanvases}ï¼‰`);
      [v, c].forEach(el=> el.classList.add('cam-fit'));

      // è¨­ç½®äº‹ä»¶ä»¥ä¾¿è§€æ¸¬ç›¸æ©Ÿç‹€æ…‹
      v.addEventListener('loadedmetadata', ()=>{
        log(`ğŸ“· ç›¸æ©Ÿå•Ÿå‹•ï¼š${v.videoWidth}x${v.videoHeight}`);
      });
      const timer = setInterval(()=>{
        log(`ğŸ“· readyState=${v.readyState} paused=${v.paused}`);
        if(v.readyState>=2) clearInterval(timer);
      },1000);

      // è¦–çª—æ”¹è®Šæ™‚ç¶­æŒæ»¿ç‰ˆ
      window.addEventListener('resize', ()=>{
        [v, c].forEach(el=>{
          el.style.width='100vw';
          el.style.height='100vh';
        });
      });
    }catch(e){
      statusEl.textContent = 'å•Ÿå‹•ä¸­ï¼ˆæœªæ‰¾åˆ°ç›¸æ©Ÿç¯€é»ï¼‰';
      log('ğŸŸ¥ ç›¸æ©Ÿç¯€é»é€¾æ™‚ï¼š'+e.message);
      log('ğŸŸ¨ æç¤ºï¼šè‹¥ä½¿ç”¨å…§å»ºç€è¦½å™¨ï¼ˆLINE/IG/FBï¼‰è«‹æ”¹ç”¨ Chromeï¼›æˆ–ç¢ºèªæ­¤ç«™é»çš„ç›¸æ©Ÿæ¬Šé™ç‚ºã€Œå…è¨±ã€ã€‚');
    }

  }catch(e){
    statusEl.textContent = 'å•Ÿå‹•å¤±æ•—';
    log('ğŸŸ¥ å•Ÿå‹•å¤±æ•—ï¼š'+e.name+' / '+e.message);
  }
};

/* ====== Anchor lock ====== */
scene.addEventListener('targetFound', ()=>{
  if(locked) return;
  log('ğŸ¯ æ‰¾åˆ°éŒ¨é» â†’ é–å®šä½å§¿');
  video.play().catch(()=>{});
  const m = marker.object3D.matrixWorld.clone();
  wall.object3D.matrix.copy(m);
  wall.object3D.matrix.decompose(wall.object3D.position, wall.object3D.quaternion, wall.object3D.scale);
  wall.object3D.scale.set(1,1,1);

  const dx = (WALL_W/2 - ANCHOR_X);
  const dy = (ANCHOR_Y - WALL_H/2);
  const q = wall.object3D.quaternion;
  const right = new THREE.Vector3(1,0,0).applyQuaternion(q);
  const up    = new THREE.Vector3(0,1,0).applyQuaternion(q);
  wall.object3D.position.addScaledVector(right, dx);
  wall.object3D.position.addScaledVector(up,    dy);

  wall.setAttribute('visible','true');
  locked = true;
  statusEl.textContent = 'å·²é–å®šï¼Œå¯æ ¡æ­£ä¸¦å„²å­˜';
  basePose = {
    pos:  wall.object3D.position.clone(),
    quat: wall.object3D.quaternion.clone(),
    scl:  wall.object3D.scale.clone()
  };
  applyResetPose();
  ctrl.style.display = 'block';
});

scene.addEventListener('loaded', ()=>{
  log('å°±ç·’ï¼šæŒ‰ã€Œå•Ÿå‹• ARã€â†’ æˆæ¬Šç›¸æ©Ÿ â†’ å°æº–éŒ¨é» â†’ è‡ªå‹•é–å®š â†’ å¾®èª¿å„²å­˜ã€‚');
  setFine();
});
</script>
</body>
</html>
